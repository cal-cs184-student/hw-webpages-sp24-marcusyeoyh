<html>

<head>
	<title>CS184 Homework 2 Writeup</title>
</head>

<body style="margin: 30 auto; width: 80%">
	<h1>CS184 Homework 2 Writeup</h1>
	<h3>Written By: Marcus Yeo (3039760661)</h3>
	<p><i>Hosted on:
			<a href="https://cal-cs184-student.github.io/hw-webpages-sp24-marcusyeoyh/hw2/index.html"
				target="_blank">https://cal-cs184-student.github.io/hw-webpages-sp24-marcusyeoyh/hw2/index.html</a>
		</i></p>
	<h2>Overview</h2>
	<h3>Q: Give a high-level overview of what you have implemented in this assignment. Think about what you have built as a whole. Share your thoughts on what interesting things you have learned from completing this assignment.</h3>
	<p>In this assignment, I implemented de Casteljau’s Algorithm, which was used to evaluate Bezier curves, and later on, Bezier Surfaces. I then used the half-edge data structure to evaluate the area-weighted vertex normal for each vertex in a mesh, which allowed for Phong shading. Following that, I implemented the edge flip and edge split functions, which would later be used in the upsampling function that I implemented, which used Loop subdivision in order to convert a coarse polygon mesh into one of higher resolution.</p>
	<p>This assignment gave me the cool opportunity to play around with the half-edge data structure and get really familiar with it. It allowed me to experience coding and exploring the different aspects that goes into upsampling as I had only ever seen the end product and not the many steps and different formulas that allow for the upsampling to occur. The implementation of area-weighted normal for every vertex was especially interesting to me as I had always been interested in learning about shading and how to create photo-realistic graphics and this section of the assignment allowed me to appreciate the complexity of shaders and how much they really improve the graphic and give it realism.</p>

	<h2>Part 1: Bezier Curves with 1D de Casteljau Subdivision (10 pts)</h2>
	<h3>Q: Briefly explain de Casteljau's algorithm and how you implemented it in order to evaluate Bezier curves.</h3>

	<p>
		De Casteljau’s Aglorithm evaluates a Bézier curve via a series of recursive linear interpolations to find n-1 new points given a set of n points and a parameter t. The algorithm gradually reduces the complexity of the problem until it reaches a single point which lies on the Bézier curve.
	</p>
	<p>
		In the function evaluateStep(), given a vector<Vector2D> points, I took each pair of adjacent points in points and performed a linear interpolation between them at the given parameter t where <i>pi′=lerp(pi,pi+1,t)=(1−t)pi+t*pi+1</i>. This new point was then pushed into a vector<Vector2D> new_points and returned as the result after all point pairs were evaluated.
	</p>

	<h3>Take a look at the provided .bzc files and create your own Bezier curve with <b>6</b> control points of your choosing. Use this Bezier curve for your screenshots below.</h3>

	<h4>Q: Show screenshots of each step / level of the evaluation from the original control points down to the final evaluated point. Press E to step through. Toggle C to show the completed Bezier curve as well.</h4>

	<div style="display: flex; justify-content: space-around; align-items: center;">
		<figure style="margin: 20px;">
			<img src="media/part1/original.png" alt="Original Control Point" style="width: 100%; height: auto;">
			<figcaption style="text-align: center;">Original Control Point</figcaption>
		</figure>
		<figure style="margin: 20px;">
			<img src="media/part1/step1.png" alt="First call to evaluateStep()" style="width: 100%; height: auto;">
			<figcaption style="text-align: center;">First call to evaluateStep()</figcaption>
		</figure>
	</div>
	<div style="display: flex; justify-content: space-around; align-items: center;">
		<figure style="margin: 20px;">
			<img src="media/part1/step2.png" alt="Second call to evaluateStep()" style="width: 100%; height: auto;">
			<figcaption style="text-align: center;">Second call to evaluateStep()</figcaption>
		</figure>
		<figure style="margin: 20px;">
			<img src="media/part1/step3.png" alt="Third call to evaluateStep()" style="width: 100%; height: auto;">
			<figcaption style="text-align: center;">Third call to evaluateStep()</figcaption>
		</figure>
	</div>
	<div style="display: flex; justify-content: space-around; align-items: center;">
		<figure style="margin: 20px;">
			<img src="media/part1/step4.png" alt="Fourth call to evaluateStep()" style="width: 100%; height: auto;">
			<figcaption style="text-align: center;">Fourth call to evaluateStep()</figcaption>
		</figure>
		<figure style="margin: 20px;">
			<img src="media/part1/step5.png" alt="Fifth call to evaluateStep()" style="width: 100%; height: auto;">
			<figcaption style="text-align: center;">Fifth call to evaluateStep()</figcaption>
		</figure>
	</div>
	<img src="media/part1/step6.png"
	style="width: 50%; height: auto; display: block; margin-left: auto; margin-right: auto;" />
	<figcaption style="text-align: center;">Completed Bezier Curve with all evaluated points</figcaption>

	<h4>Q: Show a screenshot of a slightly different Bezier curve by moving the original control points around and modifying the parameter t via mouse scrolling.</h4>
	<div style="text-align: center;">
		<figure style="display: inline-flex; justify-content: center; align-items: center; gap: 20px;">
			<img src="media/part1/ctrlptmoved1.png" alt="Different Bezier Curves obtained when control points are moved around with different t values." style="width: auto; height: auto; max-width: 45%;">
			<img src="media/part1/ctrlptmoved2.png" alt="Different Bezier Curves obtained when control points are moved around with different t values." style="width: auto; height: auto; max-width: 45%;">
		</figure>
		<figcaption style="display: block; width: 100%; text-align: center;">Different Bezier Curves obtained when control points are moved around with different t values.</figcaption>
	</div>
	

	<h2>Part 2: Bezier Surfaces with Separable 1D de Casteljau (15 pts)</h2>
	<h3>Q: Briefly explain how de Casteljau algorithm extends to Bezier surfaces and how you implemented it in order to evaluate Bezier surfaces.</h3>
	<p>De Casteljau’s Algorithm works similarly in Bezier surfaces as in curves except that it is done in two dimensions, where many Bezier curves are first plotted with De Casteljau’s Algorithm according to their rows using provided parameter u. The resultant points on each curve acts as new control points for another run of De Casteljau’s Algorithm using another provided parameter v, which plots the Bezier surface.</p>
	<p>Similar to Part 1, I implemented the one step De Casteljau Algorithm in bezierPatch::evaluateStep(), which returns a vector of intermediate Vector3D points as a result of linear interpolation with the provided parameter t.</p>
	<p>
		I then implemented evaluate1D(), which for a given vector of Vector3D control points, recursively calls evaluateStep() until only one point remains, this is the point that exists on the bezier curve for a particular row of the Bezier surface.
	</p>
	<p>
		I then implemented evaluate(), which for each row of the 2D vector controlPoints, evaluates a point on each Bezier curve for each row given a parameter u. These points are then added to a new vector of Vector3D points and are put into evaluate1D() with a parameter of u. This creates a new Bezier curve in the column direction, which when varied across u values, plots the Bezier curve. By using De Casteljau’s Algorithm on two occasions to calculate Bezier curves in the row and column dimesions respectively, we are able to evaluate a Bezier surface.
	</p>
	<h3>Q: Show a screenshot of bez/teapot.bez (not .dae) evaluated by your implementation.</h3>

	<img src="media/part2/bezsurface.png"
	style="width: 50%; height: auto; display: block; margin-left: auto; margin-right: auto;" />

	<h2>Part 3: Area-Weighted Vertex Normals (10 pts)</h2>
	<h3>Q: Briefly explain how you implemented the area-weighted vertex normals.</h3>
	<p>For the given vertex, I stored a constant iterator of its associated halfedge e, which I then traversed its next() halfedges to get the Vector3D coordinates of the other 2 points in the triangle face.</p>
	<p>
		Having coordinates of all 3 vertices, I found the vectors of two adjacent edges and obtained their cross products. This gives me the area-weighted normal for that particular triangle face. I then add the area-weighted normal to a initially zero vector n, which stores a running sum of area-weighted normal of the triangle faces incident to the vertex.
	</p>
	<p>
		I then progress halfedge e to the next of its twin and repeat the above process until we return to the original halfedge.
	</p>
	<p>
		We then normalize the vector n and return it.
	</p>

	<h3>
		Q: Show screenshots of dae/teapot.dae (not .bez) comparing teapot shading with and without vertex normals. Use Q to toggle default flat shading and Phong shading.
	</h3>

	<div style="display: flex; justify-content: space-around; align-items: center;">
		<figure style="margin: 20px;">
			<img src="media/part3/reg.png" alt="Without area-weighted vertex normals" style="width: 100%; height: auto;">
			<figcaption style="text-align: center;">Without area-weighted vertex normals</figcaption>
		</figure>
		<figure style="margin: 20px;">
			<img src="media/part3/phong.png" alt="With area-weighted vertex normals" style="width: 100%; height: auto;">
			<figcaption style="text-align: center;">With area-weighted vertex normals</figcaption>
		</figure>
	</div>

	<h2>Task 4: Edge Flip (15 pts)</h2>
	<h3>Q: Briefly explain how you implemented the edge flip operation and describe any interesting implementation / debugging tricks you have used.</h3>

	<p>
		I first started with an if loop to check if the edge is on a boundary loop and return the edge unchanged if it was.
	</p>
	<p>
		If the edge is not a boundary loop, I then find the halfedge associated with e0 and iterate through all the halfedges in the simple mesh, saving them as iterators h1 to h6. 
	</p>
	<p>
		I then found all the other elements of the simple mesh and saved them as iterators, including edges e1-e6, vertices a,b,c,d and faces f1 and f2.
	</p>
	<p>
		Having drawn out the resultant mesh as a result of edge flip, I then reassigned the twin, next, vertex, edge and face pointers for all halfedges to their new values.
	</p>
	<p>
		I then updated the halfedge attributes for all edges, vertices and faces to their new halfedges before returning the original edge e0.
	</p>


	<h3>
		Q: Show screenshots of a mesh before and after some edge flips.
	</h3>

	<div style="display: flex; justify-content: space-around; align-items: center;">
		<figure style="margin: 20px;">
			<img src="media/part4/noflip.png" alt="Before edge flips" style="width: 100%; height: auto;">
			<figcaption style="text-align: center;">Before edge flips</figcaption>
		</figure>
		<figure style="margin: 20px;">
			<img src="media/part4/flip.png" alt="After edge flips" style="width: 100%; height: auto;">
			<figcaption style="text-align: center;">After edge flips</figcaption>
		</figure>
	</div>

	<h3>Q: Write about your eventful debugging journey, if you have experienced one.</h3>

	<p>
		I initially did not know that I had to update the halfedge pointer of the edges, vertices and faces and instead did the updating wrongly. This caused the faces to not update correctly and the entire face to disappear when flip edge was called.
	</p>

	<h2>Task 5: Edge Split (15 pts)</h2>
	<h3> Q: Briefly explain how you implemented the edge split operation and describe any interesting implementation / debugging tricks you have used.
	</h3>
	<p>Similar to Part 4, I started with an if statement to check if the edge was a boundary edge and simply return the vertex associated with the edge’s halfedge if it did.</p>
	<p>I again then found the halfedge associated with e0 and iterated through all the halfedges in the simple mesh, saving them as iterators h1 to h6. </p>
	<p>I then found all the other elements of the simple mesh and saved them as iterators, including edges e1-e6, vertices a,b,c,d and faces f1 and f2.</p>
	<p>
		Since edge split requires the creation of new elements, I also initialized new iterators for halfedges h7-h12, vertex m, edges e7-e9 and faces f3 and f4.
	</p>
	<p>
		Having drawn out the resultant mesh as a result of edge flip, I then reassigned the twin, next, vertex, edge and face pointers for all halfedges to their new values.
	</p>
	<p>
		I then updated the halfedge attributes for all edges, vertices and faces to their new halfedges before returning the new vertex m.
	</p>

	<h3>Q: Show screenshots of a mesh before and after some edge splits.</h3>

	<div style="display: flex; justify-content: space-around; align-items: center;">
		<figure style="margin: 20px;">
			<img src="media/part5/nosplit.png" alt="Without any edge splits" style="width: 100%; height: auto;">
			<figcaption style="text-align: center;">Without any edge splits</figcaption>
		</figure>
		<figure style="margin: 20px;">
			<img src="media/part5/onesplit.png" alt="With one edge split" style="width: 100%; height: auto;">
			<figcaption style="text-align: center;">With one edge split</figcaption>
		</figure>
	</div>

	<img src="media/part5/manysplit.png"
	style="width: 50%; height: auto; display: block; margin-left: auto; margin-right: auto;" />
	<figcaption style="text-align: center;">With many edge splits</figcaption>

	<h3>
		Q: Show screenshots of a mesh before and after a combination of both edge splits and edge flips.
	</h3>

	<div style="display: flex; justify-content: space-around; align-items: center;">
		<figure style="margin: 20px;">
			<img src="media/part5/nosplitbean.png" alt="Without any local mesh operations" style="width: 100%; height: auto;">
			<figcaption style="text-align: center;">Without any local mesh operations</figcaption>
		</figure>
		<figure style="margin: 20px;">
			<img src="media/part5/edgeflipbean.png" alt="With edge splits" style="width: 100%; height: auto;">
			<figcaption style="text-align: center;">With edge splits</figcaption>
		</figure>
	</div>

	<img src="media/part5/edgeflipsplitbean.png"
	style="width: 50%; height: auto; display: block; margin-left: auto; margin-right: auto;" />
	<figcaption style="text-align: center;">With edge splits & edge splits</figcaption>

	<h3>
		Q: Write about your eventful debugging journey, if you have experienced one.
	</h3>

	<p>Initially, I did not know that I needed to call newHalfEdge(), newVertex(), newEdge() and newFace() when declaring new elements for the edge split operation. This resulted in many segmentation faults and a long time checking my pointer assignments.</p>

	<p>I ended up realising my mistake after reading through the halfEdgeMesh.h documentation again, which helped me realise my mistake.</p>



	<h2>Task 6: "Level Sampling" with Mipmaps for Texture Mapping</h2>
	<h3> What level sampling is and how we implemented it for texture mapping.
	</h3>
	<p>Level sampling involves storing a cache of different levels of texture samples, each with different resolutions
		such that it can be applied to the space depending on the “stretch” of the texture. </p>
	<p>To implement this, we first found the level (floating number) that corresponds to each pixel in the screen space.
		To do this, we use barycentric coordinates to find the rate of change in the x and y direction of each pixel in
		the texture space, then apply the formula to find the maximum “stretch” (L). Then, the level is computed by
		using level (D) = log2(L).</p>
	<p>To find a specific level, simply round D to the nearest integer.
	</p>
	<p>To compute the mipmap level as a continuous number, we first find the normalized distance (0<=s<=1) between D and
			its neighboring levels. We then found the colors of each pixel at the upper and lower mipmap levels, and
			computed a weighted average of the two colors using s. </p>
			<h3>Tradeoffs between speed, memory usage, and antialiasing power between the three various techniques
				(pixel sampling, level sampling, sample rate).
			</h3>

			<p>Speed:
			<ul>
				<li>Pixel Sampling: Nearest Neighbour Sampling is the fastest since it requires accessing only a singly
					texel from the texture. On the other hand, Bilinear filtering requires accessing four texels, and
					trilinear filtering requires accessing eight texels across two mipmap levels, hence as complexity of
					filtering
					increases, speed decreases.</li>
				<li>Level Sampling: using mipmaps can improve rendering speed because textures are sampled from
					lower-resolution
					images that match the screen size of the object, reducing the number of texture lookups. Mipmap
					level
					selection itself adds some computational overhead (get_level() fn) but is offset by reduced texture
					sampling
					cost.</li>
				<li>Sample Rate: Increasing the number of samples per pixel will reduce rendering speed as they require
					more
					samples per pixel, which will have to be averaged out.</li>
			</ul>

	</p>
	<p>Memory Usage:
	<ul>
		<li>Pixel Sampling: This is affected by the texture’s resolution and presence of mipmaps. Nearest neighbor does
			not require much memory usage as compared to bilinear or trilinear, which have to store much more
			information about the surrounding texels and even different mipmaps in the case of trilinear filtering</li>
		<li>Level Sampling: mipmaps increase memory usage because they require storing additional, smaller versions of
			the texture.</li>
		<li>Sample Rate: increased sample counts require more memory for framebuffer storage. Supersampling increases
			memory usage linearly with the number of samples.</li>
	</ul>
	</p>
	<p>Antialiasing Power:
	<ul>
		<li>Pixel Sampling: No antialiasing present in nearest neighbour, hence artifacts exist. Bilinear and Trilinear
			filtering offer improved antialiasing by smoothing out the textures and reduce the visibility of artifacts
			such as jaggies.</li>
		<li>Level Sampling: significantly reduced aliasing artifacts by ensuring that sampling is done from an image
			that closely matches the pixel density of the rendered object. Trilinear filtering between mipmap levels
			further smooths the transition between levels, offering a higher quality antialiasing effect</li>
		<li>Sampling Rate: Increasing the number of samples directly increases antialiasing power as the more samples
			per pixel taken means a more accurate representation of the sample image. This reduces artifacts such as
			jaggies and moire patterns.</li>
	</ul>
	</p>
	<h3>test7.svg (our own png)</h3>
	<div style="display: flex; justify-content: space-around; align-items: center;margin: 0 auto; width: 70%;"">
		<figure style=" margin: 20px;">
		<img src="media/task6/zeronearest.png" alt="Description of Image 2" style="width: 100%; height: auto;">
		<figcaption style="text-align: center;">L_ZERO and P_NEAREST</figcaption>
		</figure>
		<figure style="margin: 20px;">
			<img src="media/task6/zerolinear.png" alt="Description of Image 3" style="width: 100%; height: auto;">
			<figcaption style="text-align: center;">L_ZERO and P_LINEAR</figcaption>
		</figure>
	</div>
	<div style="display: flex; justify-content: space-around; align-items: center;margin: 0 auto; width: 70%;"">
		<figure style=" margin: 20px;">
		<img src="media/task6/nearestnearest.png" alt="Description of Image 2" style="width: 100%; height: auto;">
		<figcaption style="text-align: center;">L_NEAREST and P_NEAREST</figcaption>
		</figure>
		<figure style="margin: 20px;">
			<img src="media/task6/nearestlinear.png" alt="Description of Image 3" style="width: 100%; height: auto;">
			<figcaption style="text-align: center;">L_NEAREST and P_LINEAR</figcaption>
		</figure>
	</div>



</body>

</html>